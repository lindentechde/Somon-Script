# Advanced Types

Master SomonScript's sophisticated type system with generics, union types,
intersection types, conditional types, and advanced type manipulation
techniques.

## Generic Types

### Basic Generics

```somon
// Generic function
функсия қутии_нигоҳдори<T>(қимат: T): T {
    чоп.сабт("Нигоҳдории қимат:", қимат);
    бозгашт қимат;
}

// Usage with different types
тағйирёбанда рақам_нигоҳдошташуда = қутии_нигоҳдори<рақам>(42);
тағйирёбанда сатр_нигоҳдошташуда = қутии_нигоҳдори<сатр>("Салом");
тағйирёбанда мантиқ_нигоҳдошташуда = қутии_нигоҳдори<мантиқӣ>(дуруст);

// Type inference works too
тағйирёбанда автоматӣ = қутии_нигоҳдори("Автоматӣ тасхисшуда"); // inferred as string
```

### Generic Classes

```somon
// Generic container class
класс Омили_Нигоҳдори<T> {
    хусусӣ элементҳо: T[] = [];

    функсия илова(элемент: T): шумораи_кул {
        ин.элементҳо.push(элемент);
    }

    функсия гирифтан(индекс: рақам): T | холӣ {
        агар (индекс >= 0 && индекс < ин.элементҳо.length) {
            бозгашт ин.элементҳо[индекс];
        }
        бозгашт холӣ;
    }

    функсия ҳама(): T[] {
        бозгашт [...ин.элементҳо];
    }

    функсия дарозӣ(): рақам {
        бозгашт ин.элементҳо.length;
    }

    функсия фильтр(санҷиш: (элемент: T) => мантиқӣ): T[] {
        бозгашт ин.элементҳо.filter(санҷиш);
    }

    функсия нақша<U>(табдилдиҳанда: (элемент: T) => U): U[] {
        бозгашт ин.элементҳо.map(табдилдиҳанда);
    }
}

// Usage with specific types
тағйирёбанда рақамҳо = нав Омили_Нигоҳдори<рақам>();
рақамҳо.илова(1);
рақамҳо.илова(2);
рақамҳо.илова(3);

тағйирёбанда номҳо = нав Омили_Нигоҳдори<сатр>();
номҳо.илова("Аҳмад");
номҳо.илова("Фотима");
номҳо.илова("Алӣ");

// Advanced operations
тағйирёбанда рақамҳои_калон = рақамҳо.фильтр(рақам => рақам > 1);
тағйирёбанда дарозиҳои_номҳо = номҳо.нақша(ном => ном.length);
```

### Multiple Type Parameters

```somon
// Generic pair class
класс Ҷуфт<T, U> {
    аввал: T;
    дуюм: U;

    созанда(аввал: T, дуюм: U) {
        ин.аввал = аввал;
        ин.дуюм = дуюм;
    }

    функсия тавсиф(): сатр {
        бозгашт `Ҷуфт: (${ин.аввал}, ${ин.дуюм})`;
    }

    функсия гардонидан(): Ҷуфт<U, T> {
        бозгашт нав Ҷуфт(ин.дуюм, ин.аввал);
    }
}

// Generic map/dictionary
класс Нақшаи_Типӣ<K, V> {
    хусусӣ элементҳо = нав Map<K, V>();

    функсия танзим(калид: K, қимат: V): шумораи_кул {
        ин.элементҳо.set(калид, қимат);
    }

    функсия гирифтан(калид: K): V | холӣ {
        бозгашт ин.элементҳо.get(калид) || холӣ;
    }

    функсия дорад(калид: K): мантиқӣ {
        бозгашт ин.элементҳо.has(калид);
    }

    функсия ҳавф(калид: K): мантиқӣ {
        бозгашт ин.элементҳо.delete(калид);
    }

    функсия калидҳо(): K[] {
        бозгашт Array.from(ин.элементҳо.keys());
    }

    функсия қиматҳо(): V[] {
        бозгашт Array.from(ин.элементҳо.values());
    }
}

// Usage examples
тағйирёбанда координата = нав Ҷуфт<рақам, рақам>(10, 20);
тағйирёбанда ном_ва_синну_сол = нав Ҷуфт<сатр, рақам>("Саъид", 30);

тағйирёбанда луғати_номҳо = нав Нақшаи_Типӣ<рақам, сатр>();
луғати_номҳо.танзим(1, "Аҳмад");
луғати_номҳо.танзим(2, "Фотима");

тағйирёбанда луғати_нархҳо = нав Нақшаи_Типӣ<сатр, рақам>();
луғати_нархҳо.танзим("нон", 2.5);
луғати_нархҳо.танзим("шир", 3.0);
```

### Generic Constraints

```somon
// Constraining generics to certain types
интерфейс Дорои_Дарозӣ {
    дарозӣ: рақам;
}

функсия логи_дарозӣ<T extends Дорои_Дарозӣ>(объект: T): T {
    чоп.сабт("Дарозии объект:", объект.дарозӣ);
    бозгашт объект;
}

// Works with strings (have length property)
логи_дарозӣ("Салом дунё");   // Output: "Дарозии объект: 10"

// Works with arrays
логи_дарозӣ([1, 2, 3, 4]);   // Output: "Дарозии объект: 4"

// Constraining to object keys
функсия гирифтани_хусусият<T, K extends keyof T>(объект: T, калид: K): T[K] {
    бозгашт объект[калид];
}

тағйирёбанда шахс = { ном: "Алӣ", синну_сол: 25, шаҳр: "Душанбе" };
тағйирёбанда ном = гирифтани_хусусият(шахс, "ном");        // Type: string
тағйирёбанда синну_сол = гирифтани_хусусият(шахс, "синну_сол"); // Type: number
```

## Union Types

### Basic Union Types

```somon
// Union types allow multiple types
навъ Ҳолати_Ҷавоб = "муваффақ" | "хато" | "интизор";
навъ Рақам_ё_Сатр = рақам | сатр;

функсия коркарди_ID(id: Рақам_ё_Сатр): сатр {
    агар (typeof id === "number") {
        бозгашт "ID рақамӣ: " + id.toString();
    } вагарна {
        бозгашт "ID матнӣ: " + id;
    }
}

чоп.сабт(коркарди_ID(123));        // "ID рақамӣ: 123"
чоп.сабт(коркарди_ID("ABC123"));   // "ID матнӣ: ABC123"
```

### Complex Union Types

```somon
// Union of object types
навъ Тақвимҳои_Воқеа = {
    навъ: "ҷамъомад";
    иштирокчиён: сатр[];
    макон: сатр;
    вақт: Таърих;
} | {
    навъ: "машғулият";
    мӯҳлат: рақам; // in minutes
    мавзӯъ: сатр;
    муаллим: сатр;
} | {
    навъ: "истироҳат";
    давомнокӣ: рақам; // in minutes
};

функсия тавсифи_воқеа(воқеа: Тақвимҳои_Воқеа): сатр {
    муқоиса (воқеа.навъ) {
        ҳолат "ҷамъомад":
            бозгашт `Ҷамъомад дар ${воқеа.макон} бо ${воқеа.иштирокчиён.length} иштирокчӣ`;
        ҳолат "машғулият":
            бозгашт `Машғулияти "${воқеа.мавзӯъ}" бо ${воқеа.муаллим} (${воқеа.мӯҳлат} дақиқа)`;
        ҳолат "истироҳат":
            бозгашт `Истироҳати ${воқеа.давомнокӣ} дақиқаӣ`;
    }
}

// Usage
тағйирёбанда ҷамъомад: Тақвимҳои_Воқеа = {
    навъ: "ҷамъомад",
    иштирокчиён: ["Аҳмад", "Фотима", "Алӣ"],
    макон: "Отоқи конфронс",
    вақт: нав Date()
};

тағйирёбанда машғулият: Тақвимҳои_Воқеа = {
    навъ: "машғулият",
    мӯҳлат: 60,
    мавзӯъ: "SomonScript дар амал",
    муаллим: "Устод Саъдуллоев"
};

чоп.сабт(тавсифи_воқеа(ҷамъомад));
чоп.сабт(тавсифи_воқеа(машғулият));
```

### Type Guards

```somon
// Custom type guards
функсия ҳастӣ_рақам(қимат: any): қимат is рақам {
    бозгашт typeof қимат === "number";
}

функсия ҳастӣ_сатр(қимат: any): қимат is сатр {
    бозгашт typeof қимат === "string";
}

функсия ҳастӣ_массив<T>(қимат: any): қимат is T[] {
    бозгашт Array.isArray(қимат);
}

// Using type guards
функсия коркарди_қимати_номаълум(қимат: рақам | сатр | рақам[]): сатр {
    агар (ҳастӣ_рақам(қимат)) {
        бозгашт "Рақам: " + (қимат * 2).toString();
    } вагарна агар (ҳастӣ_сатр(қимат)) {
        бозгашт "Сатр: " + қимат.toUpperCase();
    } вагарна агар (ҳастӣ_массив<рақам>(қимат)) {
        бозгашт "Массиви рақамҳо: " + қимат.join(", ");
    } вагарна {
        бозгашт "Навъи номаълум";
    }
}
```

## Intersection Types

### Combining Types

```somon
// Intersection types combine multiple types
навъ Дорои_Ном = {
    ном: сатр;
};

навъ Дорои_Синну_сол = {
    синну_сол: рақам;
};

навъ Дорои_Электронӣ = {
    электронӣ: сатр;
};

// Intersection of all three
навъ Корбари_Пурра = Дорои_Ном & Дорои_Синну_сол & Дорои_Электронӣ;

функсия эҷоди_корбари_пурра(
    ном: сатр,
    синну_сол: рақам,
    электронӣ: сатр
): Корбари_Пурра {
    бозгашт {
        ном,
        синну_сол,
        электронӣ
    };
}

тағйирёбанда корбар = эҷоди_корбари_пурра("Алӣ", 28, "ali@example.com");
чоп.сабт(корбар.ном);        // All properties available
чоп.сабт(корбар.синну_сол);
чоп.сабт(корбар.электронӣ);
```

### Mixin Pattern with Intersections

```somon
// Base types
навъ Дорои_Ном = {
    ном: сатр;
};

навъ Дорои_Таърих = {
    эҷодшуда: Таърих;
    навсозишуда: Таърих;
};

навъ Дорои_Версия = {
    версия: рақам;
};

// Mixin functions
функсия бо_ном<T>(асос: T, ном: сатр): T & Дорои_Ном {
    бозгашт { ...асос, ном };
}

функсия бо_таърих<T>(асос: T): T & Дорои_Таърих {
    тағйирёбанда акнун = нав Date();
    бозгашт {
        ...асос,
        эҷодшуда: акнун,
        навсозишуда: акнун
    };
}

функсия бо_версия<T>(асос: T, версия: рақам = 1): T & Дорои_Версия {
    бозгашт { ...асос, версия };
}

// Building complex objects
тағйирёбанда ҳуҷҷати_асосӣ = {};
тағйирёбанда ҳуҷҷати_пурра = бо_версия(
    бо_таърих(
        бо_ном(ҳуҷҷати_асосӣ, "Ҳуҷҷати муҳим")
    ),
    2
);

чоп.сабт(ҳуҷҷати_пурра.ном);         // "Ҳуҷҷати муҳим"
чоп.сабт(ҳуҷҷати_пурра.версия);      // 2
чоп.сабт(ҳуҷҷати_пурра.эҷодшуда);    // Date object
```

## Conditional Types

### Basic Conditional Types

```somon
// Conditional type syntax: T extends U ? X : Y
навъ ҲастӣМассив<T> = T extends any[] ? дуруст : нодуруст;

навъ Санҷиш1 = ҲастӣМассив<сатр[]>;     // дуруст
навъ Санҷиш2 = ҲастӣМассив<рақам>;      // нодуруст
навъ Санҷиш3 = ҲастӣМассив<мантиқӣ[]>;  // дуруст

// Extracting return types
навъ Навъи_Бозгашт<T> = T extends (...args: any[]) => infer R ? R : never;

функсия ҳисоби_ҷамъ(а: рақам, б: рақам): рақам {
    бозгашт а + б;
}

функсия созандаи_паём(паём: сатр): сатр {
    бозгашт "Паём: " + паём;
}

навъ Навъи_Ҷамъ = Навъи_Бозгашт<typeof ҳисоби_ҷамъ>;        // рақам
навъ Навъи_Паём = Навъи_Бозгашт<typeof созандаи_паём>;       // сатр
```

### Advanced Conditional Types

```somon
// Removing null and undefined
навъ Бе_Холигӣ<T> = T extends null | undefined ? never : T;

навъ Пок1 = Бе_Холигӣ<сатр | null>;           // сатр
навъ Пок2 = Бе_Холигӣ<рақам | undefined>;     // рақам
навъ Пок3 = Бе_Холигӣ<мантиқӣ | null | undefined>; // мантиқӣ

// Conditional type with object manipulation
навъ Тариқ_бо_Танҳо_Сатрҳо<T> = {
    [K in keyof T]: T[K] extends сатр ? T[K] : never;
};

навъ Объекти_Омехта = {
    ном: сатр;
    синну_сол: рақам;
    электронӣ: сатр;
    фаъол: мантиқӣ;
};

навъ Танҳо_Сатрҳо = Тариқ_бо_Танҳо_Сатрҳо<Объекти_Омехта>;
// Result: { ном: сатр; синну_сол: never; электронӣ: сатр; фаъол: never; }

// Filtering out 'never' types
навъ Ҳақиқии_Танҳо_Сатрҳо<T> = {
    [K in keyof T as T[K] extends never ? never : K]: T[K];
};

навъ Ниҳоии_Танҳо_Сатрҳо = Ҳақиқии_Танҳо_Сатрҳо<Тариқ_бо_Танҳо_Сатрҳо<Объекти_Омехта>>;
// Result: { ном: сатр; электронӣ: сатр; }
```

## Mapped Types

### Basic Mapped Types

```somon
// Making all properties optional
навъ Ихтиёрӣ<T> = {
    [K in keyof T]?: T[K];
};

// Making all properties required
навъ Лозимӣ<T> = {
    [K in keyof T]-?: T[K];
};

// Making all properties readonly
навъ Танҳохонӣ<T> = {
    readonly [K in keyof T]: T[K];
};

// Original type
навъ Корбари_Асосӣ = {
    ном: сатр;
    синну_сол?: рақам;
    электронӣ: сатр;
};

навъ Корбари_Ихтиёрӣ = Ихтиёрӣ<Корбари_Асосӣ>;
// Result: { ном?: сатр; синну_сол?: рақам; электронӣ?: сатр; }

навъ Корбари_Лозимӣ = Лозимӣ<Корбари_Асосӣ>;
// Result: { ном: сатр; синну_сол: рақам; электронӣ: сатр; }

навъ Корбари_Танҳохонӣ = Танҳохонӣ<Корбари_Асосӣ>;
// Result: { readonly ном: сатр; readonly синну_сол?: рақам; readonly электронӣ: сатр; }
```

### Advanced Mapped Types

```somon
// Adding prefix to property names
навъ Пешванди<T, P extends сатр> = {
    [K in keyof T as `${P}${string & K}`]: T[K];
};

// Adding suffix to property names
навъ Пасванди<T, S extends сатр> = {
    [K in keyof T as `${string & K}${S}`]: T[K];
};

навъ Объекти_Тест = {
    ном: сатр;
    синну_сол: рақам;
};

навъ Бо_Пешванд = Пешванди<Объекти_Тест, "корбар_">;
// Result: { корбар_ном: сатр; корбар_синну_сол: рақам; }

навъ Бо_Пасванд = Пасванди<Объекти_Тест, "_бекор">;
// Result: { ном_бекор: сатр; синну_сол_бекор: рақам; }

// Creating getters and setters
навъ Усулҳои_Дастрасӣ<T> = {
    [K in keyof T as `гирифтан_${string & K}`]: () => T[K];
} & {
    [K in keyof T as `танзим_${string & K}`]: (қимат: T[K]) => шумораи_кул;
};

навъ Дастрасии_Корбар = Усулҳои_Дастрасӣ<Объекти_Тест>;
// Result: {
//   гирифтан_ном: () => сатр;
//   гирифтан_синну_сол: () => рақам;
//   танзим_ном: (қимат: сатр) => void;
//   танзим_синну_сол: (қимат: рақам) => void;
// }
```

## Utility Types

### Built-in Utility Types

```somon
// Pick - select specific properties
навъ Корбари_Пурра = {
    ном: сатр;
    синну_сол: рақам;
    электронӣ: сатр;
    парол: сатр;
    роли_дастрасӣ: сатр;
    охирин_воруд: Таърих;
};

навъ Корбари_Ҷамъиятӣ = Pick<Корбари_Пурра, "ном" | "синну_сол" | "электронӣ">;
// Result: { ном: сатр; синну_сол: рақам; электронӣ: сатр; }

// Omit - exclude specific properties
навъ Корбари_Бехатар = Omit<Корбари_Пурра, "парол" | "роли_дастрасӣ">;
// Result: { ном: сатр; синну_сол: рақам; электронӣ: сатр; охирин_воруд: Таърих; }

// Record - create object type with specific keys and values
навъ Луғати_Нархҳо = Record<сатр, рақам>;
тағйирёбанда нархҳои_мевањо: Луғати_Нархҳо = {
    себ: 5.0,
    банан: 3.5,
    ангур: 8.0
};

// Partial - make all properties optional
навъ Навсозии_Корбар = Partial<Корбари_Пурра>;
функсия навсозии_корбар(id: рақам, тағйирот: Навсозии_Корбар): Корбари_Пурра {
    // Implementation would merge changes with existing user
    // This is just a type example
    бозгашт {} as Корбари_Пурра;
}
```

### Custom Utility Types

```somon
// Deep readonly
навъ Амиқи_Танҳохонӣ<T> = {
    readonly [P in keyof T]: T[P] extends object ? Амиқи_Танҳохонӣ<T[P]> : T[P];
};

// Deep partial
навъ Амиқи_Ихтиёрӣ<T> = {
    [P in keyof T]?: T[P] extends object ? Амиқи_Ихтиёрӣ<T[P]> : T[P];
};

// Extract function names
навъ Номҳои_Функсия<T> = {
    [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];

класс Муҳасибӣ {
    ном: сатр = "";
    мавҷудга: рақам = 0;

    функсия ҳисоб(): рақам { бозгашт ин.мавҷудга; }
    функсия барориш(миқдор: рақам): шумораи_кул { ин.мавҷудга -= миқдор; }
    функсия илова(миқдор: рақам): шумораи_кул { ин.мавҷудга += миқдор; }
}

навъ Усулҳои_Муҳасибӣ = Номҳои_Функсия<Муҳасибӣ>;
// Result: "ҳисоб" | "барориш" | "илова"

// Function type extraction
навъ Навъҳои_Функсия<T> = {
    [K in keyof T]: T[K] extends Function ? T[K] : never;
};

навъ Функсияҳои_Муҳасибӣ = Навъҳои_Функсия<Муҳасибӣ>;
```

## Type Manipulation Patterns

### Type-safe Event System

```somon
// Event map definition
интерфейс Нақшаи_Рӯйдодҳо {
    "user-login": { корбар: сатр; вақт: Таърих };
    "user-logout": { корбар: сатр };
    "data-update": { ҷадвал: сатр; ҳуҷраҳо: рақам };
    "error-occurred": { паём: сатр; код: рақам };
}

// Type-safe event emitter
класс Рӯйдодгузор {
    хусусӣ шунавандагон = нав Map<keyof Нақшаи_Рӯйдодҳо, Function[]>();

    гӯш<K extends keyof Нақшаи_Рӯйдодҳо>(
        рӯйдод: K,
        шунаванда: (маълумот: Нақшаи_Рӯйдодҳо[K]) => шумораи_кул
    ): шумораи_кул {
        агар (!ин.шунавандагон.has(рӯйдод)) {
            ин.шунавандагон.set(рӯйдод, []);
        }
        ин.шунавандагон.get(рӯйдод)!.push(шунаванда);
    }

    фиристодан<K extends keyof Нақшаи_Рӯйдодҳо>(
        рӯйдод: K,
        маълумот: Нақшаи_Рӯйдодҳо[K]
    ): шумораи_кул {
        тағйирёбанда шунавандагон = ин.шунавандагон.get(рӯйдод);
        агар (шунавандагон) {
            барои (тағйирёбанда шунаванда аз шунавандагон) {
                шунаванда(маълумот);
            }
        }
    }
}

// Usage with full type safety
тағйирёбанда событiya = нав Рӯйдодгузор();

рӯйдодгузор.гӯш("user-login", (маълумот) => {
    // маълумот is typed as { корбар: сатр; вақт: Таърих }
    чоп.сабт(`Корбари ${маълумот.корбар} дохил шуд дар ${маълумот.вақт}`);
});

рӯйдодгузор.фиристодан("user-login", {
    корбар: "Алӣ",
    вақт: нав Date()
});
```

### API Response Types

```somon
// Generic API response structure
навъ Ҷавоби_API<T> = {
    муваффақ: дуруст;
    маълумот: T;
    паём?: сатр;
} | {
    муваффақ: нодуруст;
    хато: сатр;
    код_хато: рақам;
};

// Specific API responses
навъ Ҷавоби_Корбар = Ҷавоби_API<{
    id: рақам;
    ном: сатр;
    электронӣ: сатр;
}>;

навъ Ҷавоби_Рӯйхати_Корбарон = Ҷавоби_API<{
    корбарон: Array<{ id: рақам; ном: сатр; электронӣ: сатр; }>;
    шумораи_кул: рақам;
    саҳифа: рақам;
}>;

// Type-safe API handler
async функсия коркарди_ҷавоби_API<T>(
    ваъда: Promise<Ҷавоби_API<T>>
): Promise<T> {
    тағйирёбанда ҷавоб = await ваъда;

    агар (ҷавоб.муваффақ) {
        бозгашт ҷавоб.маълумот;
    } вагарна {
        партофтан нав Error(`API хато: ${ҷавоб.хато} (код: ${ҷавоб.код_хато})`);
    }
}

// Usage
async функсия гирифтани_корбар(id: рақам): Promise<{ id: рақам; ном: сатр; электронӣ: сатр; }> {
    тағйирёбанда ҷавоб: Ҷавоби_Корбар = await fetch(`/api/users/${id}`).then(r => r.json());
    бозгашт коркарди_ҷавоби_API(Promise.resolve(ҷавоб));
}
```

## Real-world Examples

### Form Validation System

```somon
// Field validation types
навъ Санҷиш<T> = (қимат: T) => сатр | холӣ; // returns error message or null

навъ Қоидаҳои_Эътибор<T> = {
    [K in keyof T]: Санҷиш<T[K]>[];
};

навъ Хатоҳои_Эътибор<T> = {
    [K in keyof T]?: сатр;
};

// Validation class
класс Эътиборсанҷ<T> {
    хусусӣ қоидаҳо: Қоидаҳои_Эътибор<T>;

    созанда(қоидаҳо: Қоидаҳои_Эътибор<T>) {
        ин.қоидаҳо = қоидаҳо;
    }

    санҷиш(маълумот: T): Хатоҳои_Эътибор<T> {
        тағйирёбанда хатоҳо: Хатоҳои_Эътибор<T> = {};

        барои (тағйирёбанда калид дар ин.қоидаҳо) {
            тағйирёбанда қимат = маълумот[калид];
            тағйирёбанда қоидаҳои_майдон = ин.қоидаҳо[калид];

            барои (тағйирёбанда қоида аз қоидаҳои_майдон) {
                тағйирёбанда хато = қоида(қимат);
                агар (хато) {
                    хатоҳо[калид] = хато;
                    шикастан; // Stop at first error
                }
            }
        }

        бозгашт хатоҳо;
    }

    ҳақиқат(маълумот: T): мантиқӣ {
        тағйирёбанда хатоҳо = ин.санҷиш(маълумот);
        бозгашт Object.keys(хатоҳо).length === 0;
    }
}

// Common validators
тағйирёбанда зарурӣ: Санҷиш<сатр> = (қимат) => {
    агар (!қимат || қимат.trim().length === 0) {
        бозгашт "Ин майдон зарурӣ аст";
    }
    бозгашт холӣ;
};

тағйирёбанда ақаллан_дарозӣ = (ақаллан: рақам): Санҷиш<сатр> => (қимат) => {
    агар (қимат.length < ақаллан) {
        бозгашт `Ақаллан ${ақаллан} ҳарф лозим аст`;
    }
    бозгашт холӣ;
};

тағйирёбанда электронии_ҳақиқӣ: Санҷиш<сатр> = (қимат) => {
    тағйирёбанда намуна = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    агар (!намуна.test(қимат)) {
        бозгашт "Суроғаи электронӣ нодуруст аст";
    }
    бозгашт холӣ;
};

// Form type
навъ Шакли_Қайдият = {
    ном: сатр;
    электронӣ: сатр;
    парол: сатр;
    тасдиқи_парол: сатр;
};

// Validator setup
тағйирёбанда эътиборсанҷи_қайдият = нав Эътиборсанҷ<Шакли_Қайдият>({
    ном: [зарурӣ, ақаллан_дарозӣ(2)],
    электронӣ: [зарурӣ, электронии_ҳақиқӣ],
    парол: [зарурӣ, ақаллан_дарозӣ(8)],
    тасдиқи_парол: [зарурӣ]
});

// Usage
тағйирёбанда маълумоти_корбар: Шакли_Қайдият = {
    ном: "Алӣ",
    электронӣ: "ali@example.com",
    парол: "password123",
    тасдиқи_парол: "password123"
};

тағйирёбанда хатоҳо = эътиборсанҷи_қайдият.санҷиш(маълумоти_корбар);
агар (Object.keys(хатоҳо).length === 0) {
    чоп.сабт("Шакл эътибор ёфт!");
} вагарна {
    чоп.хато("Хатоҳои эътибор:", хатоҳо);
}
```

## Best Practices

### 1. Use Type Unions for State

```somon
// ✅ Good: Clear state modeling
навъ Ҳолати_Боркунӣ =
    | { ҳолат: "интизор" }
    | { ҳолат: "боркунӣ" }
    | { ҳолат: "муваффақ"; маълумот: any }
    | { ҳолат: "хато"; паём: сатр };

функсия коркарди_ҳолат(ҳолат: Ҳолати_Боркунӣ): сатр {
    муқоиса (ҳолат.ҳолат) {
        ҳолат "интизор":
            бозгашт "Омода барои бор кардан...";
        ҳолат "боркунӣ":
            бозгашт "Дар ҳоли бор...";
        ҳолат "муваффақ":
            бозгашт "Маълумот бор шуд: " + JSON.stringify(ҳолат.маълумот);
        ҳолат "хато":
            бозгашт "Хато: " + ҳолат.паём;
    }
}
```

### 2. Prefer Type Composition

```somon
// ✅ Good: Composable types
навъ Асосӣ = {
    id: рақам;
    эҷодшуда: Таърих;
    навсозишуда: Таърих;
};

навъ Дорои_Ном = {
    ном: сатр;
};

навъ Дорои_Тавсиф = {
    тавсиф?: сатр;
};

навъ Маҳсулот = Асосӣ & Дорои_Ном & Дорои_Тавсиф & {
    нарх: рақам;
    мавҷуд: мантиқӣ;
};

навъ Категория = Асосӣ & Дорои_Ном & Дорои_Тавсиф;
```

### 3. Use Generic Constraints Wisely

```somon
// ✅ Good: Meaningful constraints
интерфейс Дорои_ID {
    id: рақам;
}

функсия навсозӣ<T extends Дорои_ID>(объект: T, тағйирот: Partial<T>): T {
    бозгашт { ...объект, ...тағйирот };
}

// Works with any object that has an id
тағйирёбанда корбар = { id: 1, ном: "Алӣ", синну_сол: 25 };
тағйирёбанда корбари_навсозишуда = навсозӣ(корбар, { синну_сол: 26 });
```

### 4. Avoid Complex Type Gymnastics

```somon
// ❌ Avoid: Overly complex types
навъ Навъи_Мураккаби_Бад<T> = T extends {
    [K in keyof T]: T[K] extends Function
        ? T[K] extends (...args: infer P) => infer R
            ? P extends any[]
                ? R extends Promise<infer U>
                    ? U
                    : R
                : never
            : never
        : T[K];
}[keyof T] ? дуруст : нодуруст;

// ✅ Good: Simple, clear types
навъ Навъи_Равшан<T> = T extends Promise<infer U> ? U : T;
```

## Next Steps

You've mastered SomonScript's advanced type system! Continue exploring:

1. **[How-to Guides](../how-to/)** - Practical implementation patterns
2. **[Reference - Types](../reference/types.md)** - Complete type system
   reference
3. **[Examples](../../examples/)** - Real-world SomonScript applications

---

**Ready for practical patterns?** → [How-to Guides](../how-to/)
